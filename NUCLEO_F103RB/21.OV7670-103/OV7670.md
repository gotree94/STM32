# 21.OV7670

<img width="453" height="451" alt="stm32f103" src="https://github.com/user-attachments/assets/c8c2d4af-5ba4-43ff-8ec5-fe5e54d08675" />

<img width="800" height="600" alt="006" src="https://github.com/user-attachments/assets/70697c52-b2e6-4004-9935-0901b7ed0f6b" />

<img width="800" height="600" alt="001" src="https://github.com/user-attachments/assets/13cccac6-2bfa-44bc-a752-0504a97dd8f8" />

<img width="800" height="600" alt="002" src="https://github.com/user-attachments/assets/a1f7adc1-817d-453b-a14c-458a923ee2b8" />

<img width="800" height="600" alt="003" src="https://github.com/user-attachments/assets/a6d0cb28-707e-43b7-b554-bbfe80143b32" />

<img width="800" height="600" alt="004" src="https://github.com/user-attachments/assets/74ce7870-6438-4e65-bb8e-77bca29499f5" />

<img width="800" height="600" alt="005" src="https://github.com/user-attachments/assets/ba34d749-5219-44f7-a96f-a3bc84e43c48" />

```c
/* USER CODE BEGIN Includes */
#include <stdio.h>
#include <string.h>
/* USER CODE END Includes */
```

```c
/* USER CODE BEGIN PD */
// OV7670 I2C Address
#define OV7670_I2C_ADDR         0x42  // 7-bit address shifted left (0x21 << 1)

// Key OV7670 Registers for status check
#define OV7670_REG_PID          0x0A  // Product ID MSB (should be 0x76)
#define OV7670_REG_VER          0x0B  // Product ID LSB (should be 0x73)
#define OV7670_REG_MIDH         0x1C  // Manufacturer ID MSB (should be 0x7F)
#define OV7670_REG_MIDL         0x1D  // Manufacturer ID LSB (should be 0xA2)
#define OV7670_REG_COM1         0x04  // Common control 1
#define OV7670_REG_COM7         0x12  // Common control 7
#define OV7670_REG_COM10        0x15  // Common control 10
#define OV7670_REG_CLKRC        0x11  // Clock control

// I2C Pin definitions for PB8/PB9
#define I2C_SCL_PIN             GPIO_PIN_8  // PB8
#define I2C_SDA_PIN             GPIO_PIN_9  // PB9
#define I2C_GPIO_PORT           GPIOB

// XCLK Pin (MCO1 output)
#define XCLK_PIN                GPIO_PIN_8  // PA8
#define XCLK_GPIO_PORT          GPIOA
/* USER CODE END PD */
```

```c
/* USER CODE BEGIN PFP */
static void Configure_MCO1_Output(void);
/* USER CODE END PFP */
```

```c
/* USER CODE BEGIN 0 */

#ifdef __GNUC__
#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
#else
#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
#endif /* __GNUC__ */

/**
  * @brief  Retargets the C library printf function to the USART.
  */
PUTCHAR_PROTOTYPE
{
    if (ch == '\n')
        HAL_UART_Transmit(&huart2, (uint8_t*)"\r", 1, 0xFFFF);
    HAL_UART_Transmit(&huart2, (uint8_t*)&ch, 1, 0xFFFF);
    return ch;
}

/**
  * @brief  MCO (PA8) 클럭 출력 설정 - STM32F103용
  * @note   F103에서는 MCOConfig 함수 사용법이 다름
  *         가능한 출력: SYSCLK, HSI, HSE, PLLCLK/2
  */
static void Configure_MCO1_Output(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    printf("\n=== Configuring MCO for XCLK (STM32F103) ===\n");
    
    // GPIOA 클럭 활성화
    __HAL_RCC_GPIOA_CLK_ENABLE();
    
    // PA8을 MCO Alternate Function으로 설정
    // F103은 AF 번호가 없고 GPIO_MODE_AF_PP만 사용
    GPIO_InitStruct.Pin = XCLK_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;  // F103: AF 번호 불필요
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    HAL_GPIO_Init(XCLK_GPIO_PORT, &GPIO_InitStruct);
    
    // MCO 출력 설정
    // F103의 경우 HAL_RCC_MCOConfig는 2개 파라미터만 사용
    // RCC_MCO1SOURCE_PLLCLK를 사용하면 PLLCLK/2가 출력됨
    
    // Option 1: PLLCLK/2 = 64MHz/2 = 32MHz (너무 높음)
    // HAL_RCC_MCOConfig(RCC_MCO, RCC_MCO1SOURCE_PLLCLK);
    
    // Option 2: SYSCLK = 64MHz (너무 높음)
    // HAL_RCC_MCOConfig(RCC_MCO, RCC_MCO1SOURCE_SYSCLK);
    
    // Option 3: HSE (외부 크리스탈 사용시)
    // 8MHz HSE를 사용한다면 8MHz 출력 (너무 낮음)
    // HAL_RCC_MCOConfig(RCC_MCO, RCC_MCO1SOURCE_HSE);
    
    // F103의 문제: PLLCLK/2가 최소 분주비
    // 64MHz 시스템에서는 32MHz가 최소값
    // OV7670은 10~48MHz 지원하므로 32MHz도 가능
    
    HAL_RCC_MCOConfig(RCC_MCO, RCC_MCO1SOURCE_PLLCLK);  // PLLCLK/2 출력
    
    printf("✓ MCO configured: PA8 output = 32MHz\n");
    printf("  Source: PLLCLK/2 (64MHz / 2)\n");
    printf("  Note: F103 cannot divide further\n");
    printf("  OV7670 supports 10~48MHz, 32MHz is acceptable\n");
    printf("==========================================\n\n");
    
    // XCLK 안정화 대기
    printf("Waiting for XCLK stabilization (500ms)...\n");
    HAL_Delay(500);
    printf("✓ XCLK should be stable now\n\n");
}

/**
  * @brief  XCLK 출력 소스 변경 - STM32F103용
  * @param  source: 1=HSI, 2=HSE, 3=SYSCLK, 4=PLLCLK/2
  */
void Change_XCLK_Source(uint32_t source)
{
    printf("\n=== Changing XCLK Source (F103) ===\n");
    
    uint32_t mco_source;
    const char* source_name;
    const char* output_freq;
    
    switch(source) {
        case 1:
            mco_source = RCC_MCO1SOURCE_HSI;
            source_name = "HSI";
            output_freq = "8MHz";
            break;
        case 2:
            mco_source = RCC_MCO1SOURCE_HSE;
            source_name = "HSE";
            output_freq = "8MHz (if 8MHz crystal)";
            break;
        case 3:
            mco_source = RCC_MCO1SOURCE_SYSCLK;
            source_name = "SYSCLK";
            output_freq = "64MHz";
            break;
        case 4:
        default:
            mco_source = RCC_MCO1SOURCE_PLLCLK;
            source_name = "PLLCLK/2";
            output_freq = "32MHz (64MHz / 2)";
            break;
    }
    
    HAL_RCC_MCOConfig(RCC_MCO, mco_source);
    
    printf("✓ XCLK source changed to %s\n", source_name);
    printf("  Output frequency: %s\n", output_freq);
    printf("===================================\n\n");
    
    HAL_Delay(100);
}

/**
  * @brief  OV7670 레지스터 읽기
  */
HAL_StatusTypeDef OV7670_ReadRegister(uint8_t reg_addr, uint8_t *data)
{
    HAL_StatusTypeDef status;
    status = HAL_I2C_Master_Transmit(&hi2c1, OV7670_I2C_ADDR, &reg_addr, 1, 1000);
    if (status != HAL_OK) return status;
    status = HAL_I2C_Master_Receive(&hi2c1, OV7670_I2C_ADDR, data, 1, 1000);
    return status;
}

/**
  * @brief  OV7670 레지스터 쓰기
  */
HAL_StatusTypeDef OV7670_WriteRegister(uint8_t reg_addr, uint8_t data)
{
    uint8_t buf[2] = {reg_addr, data};
    return HAL_I2C_Master_Transmit(&hi2c1, OV7670_I2C_ADDR, buf, 2, 1000);
}

/**
  * @brief  I2C 핀 GPIO 설정 - STM32F103용
  * @note   F103은 AF 번호 대신 Remap 사용
  */
void Force_I2C1_GPIO_Config(void)
{
    printf("\n=== Forcing I2C1 GPIO Configuration (PB8/PB9) ===\n");
    
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    __HAL_RCC_GPIOB_CLK_ENABLE();
    __HAL_RCC_AFIO_CLK_ENABLE();  // F103: AFIO 클럭 필요
    
    // F103: I2C1 Remap 설정 (PB8/PB9 사용시)
    // PB6/PB7: 기본 핀 (Remap 불필요)
    // PB8/PB9: Remap 필요
    __HAL_AFIO_REMAP_I2C1_ENABLE();
    
    // PB8 (SCL), PB9 (SDA) 설정
    GPIO_InitStruct.Pin = I2C_SCL_PIN | I2C_SDA_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;  // F103: Open Drain, AF 번호 없음
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    // F103에는 Pull 설정이 없음 (외부 풀업 사용)
    
    HAL_GPIO_Init(I2C_GPIO_PORT, &GPIO_InitStruct);
    
    printf("✓ GPIO configuration completed (F103 style)\n");
    printf("  I2C1 Remap enabled for PB8/PB9\n");
    printf("==============================================\n\n");
}
/**
  * @brief  I2C 핀 설정 및 상태 확인
  */
void I2C_CheckPinStatus(void)
{
    printf("\n=== I2C Configuration Check (PB8/PB9) ===\n");

    printf("I2C1->CR1: 0x%04X ", (uint16_t)I2C1->CR1);
    printf("(PE: %s)\n", (I2C1->CR1 & I2C_CR1_PE) ? "Enabled" : "Disabled");

    printf("I2C1->SR1: 0x%04X\n", (uint16_t)I2C1->SR1);
    printf("I2C1->SR2: 0x%04X\n", (uint16_t)I2C1->SR2);

    if (RCC->AHB1ENR & RCC_AHB1ENR_GPIOBEN) {
        printf("✓ GPIOB clock enabled\n");
    } else {
        printf("✗ GPIOB clock disabled\n");
    }

    if (RCC->APB1ENR & RCC_APB1ENR_I2C1EN) {
        printf("✓ I2C1 clock enabled\n");
    } else {
        printf("✗ I2C1 clock disabled\n");
    }

    uint32_t moder_val = GPIOB->MODER;
    uint32_t afr_val = GPIOB->AFR[1];

    uint32_t pb8_mode = (moder_val >> (8 * 2)) & 0x3;
    uint32_t pb9_mode = (moder_val >> (9 * 2)) & 0x3;
    uint32_t pb8_af = (afr_val >> ((8-8) * 4)) & 0xF;
    uint32_t pb9_af = (afr_val >> ((9-8) * 4)) & 0xF;

    printf("PB8 (SCL) Mode: ");
    switch (pb8_mode) {
        case 0: printf("Input"); break;
        case 1: printf("Output"); break;
        case 2: printf("Alternate Function (AF%lu)", pb8_af); break;
        case 3: printf("Analog"); break;
    }
    printf("\n");

    printf("PB9 (SDA) Mode: ");
    switch (pb9_mode) {
        case 0: printf("Input"); break;
        case 1: printf("Output"); break;
        case 2: printf("Alternate Function (AF%lu)", pb9_af); break;
        case 3: printf("Analog"); break;
    }
    printf("\n");

    if (pb8_mode == 2 && pb9_mode == 2 && pb8_af == 4 && pb9_af == 4) {
        printf("✓ PB8/PB9 correctly configured for I2C1 (AF4)\n");
    } else {
        printf("✗ GPIO pins not properly configured for I2C\n");
    }

    printf("======================================\n\n");
}

/**
  * @brief  I2C 버스 스캔
  */
void I2C_Scanner(void)
{
    printf("\n=== I2C Bus Scanner ===\n");
    printf("Scanning I2C addresses from 0x08 to 0x77...\n");

    uint8_t found_devices = 0;

    for (uint8_t addr = 0x08; addr <= 0x77; addr++) {
        HAL_StatusTypeDef result = HAL_I2C_IsDeviceReady(&hi2c1, addr << 1, 1, 100);

        if (result == HAL_OK) {
            printf("✓ Device found at 8-bit addr: 0x%02X (7-bit: 0x%02X)\n", addr << 1, addr);
            found_devices++;

            if (addr == 0x21 || addr == 0x42 || addr == 0x60) {
                printf("  --> This could be OV7670!\n");
            }
        }
    }

    if (found_devices == 0) {
        printf("❌ No I2C devices found!\n");
        printf("Make sure XCLK is connected and running!\n");
    } else {
        printf("Total devices found: %d\n", found_devices);
    }
    printf("======================\n\n");
}

/**
  * @brief  다양한 OV7670 주소로 ID 읽기 시도
  */
void OV7670_TryMultipleAddresses(void)
{
    printf("\n=== OV7670 Multi-Address Test ===\n");

    uint8_t possible_addresses[] = {0x42, 0x43, 0x60, 0x61};
    uint8_t num_addresses = sizeof(possible_addresses) / sizeof(possible_addresses[0]);

    for (uint8_t i = 0; i < num_addresses; i++) {
        uint8_t addr = possible_addresses[i];
        printf("Trying address 0x%02X (7-bit: 0x%02X)...\n", addr, addr >> 1);

        HAL_StatusTypeDef ready_result = HAL_I2C_IsDeviceReady(&hi2c1, addr, 3, 100);
        if (ready_result == HAL_OK) {
            printf("  ✓ Device responds at this address\n");

            uint8_t reg_addr = 0x0A;
            uint8_t pid_value = 0;

            HAL_StatusTypeDef tx_result = HAL_I2C_Master_Transmit(&hi2c1, addr, &reg_addr, 1, 1000);
            if (tx_result == HAL_OK) {
                HAL_StatusTypeDef rx_result = HAL_I2C_Master_Receive(&hi2c1, addr, &pid_value, 1, 1000);
                if (rx_result == HAL_OK) {
                    printf("  ✓ PID Register (0x0A): 0x%02X\n", pid_value);
                    if (pid_value == 0x76) {
                        printf("  🎯 FOUND OV7670! Address: 0x%02X\n", addr);

                        uint8_t ver_addr = 0x0B;
                        uint8_t ver_value = 0;
                        HAL_I2C_Master_Transmit(&hi2c1, addr, &ver_addr, 1, 1000);
                        HAL_I2C_Master_Receive(&hi2c1, addr, &ver_value, 1, 1000);
                        printf("  ✓ VER Register (0x0B): 0x%02X\n", ver_value);

                        if (ver_value == 0x73) {
                            printf("  🎉 CONFIRMED: Valid OV7670 at address 0x%02X!\n", addr);
                        }
                    }
                }
            }
        } else {
            printf("  ✗ No response at this address\n");
        }
        printf("\n");
    }
    printf("===============================\n\n");
}

/**
  * @brief  OV7670 센서 ID 확인
  */
uint8_t OV7670_CheckID(void)
{
    uint8_t pid, ver, midh, midl;
    HAL_StatusTypeDef status;

    printf("\n=== OV7670 ID Check ===\n");

    status = OV7670_ReadRegister(OV7670_REG_PID, &pid);
    if (status != HAL_OK) {
        printf("Failed to read PID register (0x%02X)\n", OV7670_REG_PID);
        return 0;
    }

    status = OV7670_ReadRegister(OV7670_REG_VER, &ver);
    if (status != HAL_OK) {
        printf("Failed to read VER register (0x%02X)\n", OV7670_REG_VER);
        return 0;
    }

    status = OV7670_ReadRegister(OV7670_REG_MIDH, &midh);
    if (status != HAL_OK) {
        printf("Failed to read MIDH register (0x%02X)\n", OV7670_REG_MIDH);
        return 0;
    }

    status = OV7670_ReadRegister(OV7670_REG_MIDL, &midl);
    if (status != HAL_OK) {
        printf("Failed to read MIDL register (0x%02X)\n", OV7670_REG_MIDL);
        return 0;
    }

    printf("Product ID: 0x%02X%02X (Expected: 0x7673)\n", pid, ver);
    printf("Manufacturer ID: 0x%02X%02X (Expected: 0x7FA2)\n", midh, midl);

    if (pid == 0x76 && ver == 0x73 && midh == 0x7F && midl == 0xA2) {
        printf("✓ OV7670 sensor detected successfully!\n");
        return 1;
    } else {
        printf("✗ Invalid sensor ID - may be faulty or not OV7670\n");
        return 0;
    }
}

/**
  * @brief  OV7670 주요 레지스터 상태 확인
  */
void OV7670_CheckRegisters(void)
{
    uint8_t reg_value;
    HAL_StatusTypeDef status;

    printf("\n=== OV7670 Register Status ===\n");

    status = OV7670_ReadRegister(OV7670_REG_CLKRC, &reg_value);
    printf("CLKRC (0x%02X): 0x%02X %s\n",
           OV7670_REG_CLKRC, reg_value,
           (status == HAL_OK) ? "✓" : "✗");

    status = OV7670_ReadRegister(OV7670_REG_COM1, &reg_value);
    printf("COM1  (0x%02X): 0x%02X %s\n",
           OV7670_REG_COM1, reg_value,
           (status == HAL_OK) ? "✓" : "✗");

    status = OV7670_ReadRegister(OV7670_REG_COM7, &reg_value);
    printf("COM7  (0x%02X): 0x%02X %s",
           OV7670_REG_COM7, reg_value,
           (status == HAL_OK) ? "✓" : "✗");
    if (status == HAL_OK) {
        printf(" (Reset: %s, Format: %s)",
               (reg_value & 0x80) ? "Active" : "Normal",
               (reg_value & 0x04) ? "RGB" : "YUV");
    }
    printf("\n");

    status = OV7670_ReadRegister(OV7670_REG_COM10, &reg_value);
    printf("COM10 (0x%02X): 0x%02X %s",
           OV7670_REG_COM10, reg_value,
           (status == HAL_OK) ? "✓" : "✗");
    if (status == HAL_OK) {
        printf(" (HSYNC: %s, VSYNC: %s)",
               (reg_value & 0x40) ? "Active Low" : "Active High",
               (reg_value & 0x20) ? "Active Low" : "Active High");
    }
    printf("\n");

    printf("============================\n\n");
}

/**
  * @brief  OV7670 기본 설정 테스트
  */
void OV7670_BasicConfigTest(void)
{
    printf("\n=== OV7670 Basic Config Test ===\n");

    printf("Testing software reset...\n");
    HAL_StatusTypeDef status = OV7670_WriteRegister(OV7670_REG_COM7, 0x80);
    if (status == HAL_OK) {
        printf("✓ Software reset command sent\n");
        HAL_Delay(100);

        uint8_t pid;
        status = OV7670_ReadRegister(OV7670_REG_PID, &pid);
        if (status == HAL_OK && pid == 0x76) {
            printf("✓ Sensor responsive after reset\n");
        } else {
            printf("✗ Sensor not responsive after reset\n");
        }
    } else {
        printf("✗ Failed to send software reset\n");
    }

    printf("Testing clock divider setting...\n");
    status = OV7670_WriteRegister(OV7670_REG_CLKRC, 0x00);
    if (status == HAL_OK) {
        uint8_t clkrc_read;
        status = OV7670_ReadRegister(OV7670_REG_CLKRC, &clkrc_read);
        if (status == HAL_OK) {
            printf("✓ CLKRC write/read test: wrote 0x00, read 0x%02X\n", clkrc_read);
        } else {
            printf("✗ Failed to read back CLKRC\n");
        }
    } else {
        printf("✗ Failed to write CLKRC\n");
    }

    printf("===============================\n\n");
}

/**
  * @brief  완전한 I2C1 재초기화
  */
void Complete_I2C1_Reinit(void)
{
    printf("\n=== Complete I2C1 Reinitialization ===\n");

    printf("Step 1: Deinitializing I2C1...\n");
    HAL_I2C_DeInit(&hi2c1);

    printf("Step 2: Resetting clocks...\n");
    __HAL_RCC_I2C1_CLK_DISABLE();
    __HAL_RCC_I2C1_FORCE_RESET();
    HAL_Delay(10);
    __HAL_RCC_I2C1_RELEASE_RESET();
    __HAL_RCC_I2C1_CLK_ENABLE();

    printf("Step 3: Forcing GPIO configuration...\n");
    Force_I2C1_GPIO_Config();

    printf("Step 4: Reinitializing I2C1...\n");
    if (HAL_I2C_Init(&hi2c1) != HAL_OK) {
        printf("✗ I2C1 initialization failed!\n");
    } else {
        printf("✓ I2C1 initialized successfully!\n");
    }

    printf("Step 5: Verifying configuration...\n");
    I2C_CheckPinStatus();

    printf("=====================================\n\n");
}

/**
  * @brief  시스템 정보 출력 - STM32F103용
  */
void PrintSystemInfo(void)
{
    printf("\n=== System Information ===\n");
    printf("MCU: STM32F103\n");
    printf("Clock Frequency: 64 MHz\n");
    printf("I2C Interface: I2C1 (PB8=SCL, PB9=SDA)\n");
    printf("UART Interface: UART2 (PA2=TX, PA3=RX)\n");
    printf("XCLK Output: PA8 (MCO) @ 32MHz\n");
    printf("OV7670 I2C Address: 0x%02X (7-bit: 0x%02X)\n", OV7670_I2C_ADDR, OV7670_I2C_ADDR >> 1);
    printf("=========================\n\n");
}

/**
  * @brief  명령어 처리
  */
void ProcessCommand(char cmd)
{
    switch (cmd) {
        case 's':
        case 'S':
            I2C_Scanner();
            break;

        case 'p':
        case 'P':
            I2C_CheckPinStatus();
            break;

        case 'f':
        case 'F':
            Force_I2C1_GPIO_Config();
            break;

        case 'x':
        case 'X':
            Complete_I2C1_Reinit();
            break;

        case 'c':
        case 'C':
            Configure_MCO1_Output();
            break;

        case '1':
        case '2':
        case '3':
        case '4':
            Change_XCLK_Source(cmd - '0');
            break;
        case '5':
            Change_XCLK_Frequency(cmd - '0');
            break;

        case 'm':
        case 'M':
            OV7670_TryMultipleAddresses();
            break;

        case 'i':
        case 'I':
            OV7670_CheckID();
            break;

        case 'r':
        case 'R':
            OV7670_CheckRegisters();
            break;

        case 't':
        case 'T':
            OV7670_BasicConfigTest();
            break;

        case 'a':
        case 'A':
            printf("Running COMPLETE diagnostic with XCLK...\n\n");
            Configure_MCO1_Output();
            Complete_I2C1_Reinit();
            I2C_Scanner();
            OV7670_TryMultipleAddresses();
            if (OV7670_CheckID()) {
                OV7670_CheckRegisters();
                OV7670_BasicConfigTest();
            }
            break;

        case 'h':
        case 'H':
        case '?':
            printf("\n=== OV7670 Diagnostic Commands ===\n");
            printf("S - I2C bus scan\n");
            printf("P - Check I2C pin configuration\n");
            printf("F - Force GPIO configuration\n");
            printf("X - Complete I2C reinitialization\n");
            printf("C - Configure/Restart XCLK output\n");
            printf("1-4 - Change XCLK source\n");
            printf("      1=HSI(8MHz), 2=HSE(8MHz), 3=SYSCLK(64MHz), 4=PLLCLK/2(32MHz)\n");
            printf("M - Try multiple OV7670 addresses\n");
            printf("I - Check OV7670 ID\n");
            printf("R - Read key registers\n");
            printf("T - Basic configuration test\n");
            printf("A - Run ALL diagnostic tests\n");
            printf("H - Show this help\n");
            printf("===================================\n\n");
            break;

        default:
            printf("Unknown command: %c\n", cmd);
            printf("Type 'H' for help\n\n");
            break;
    }
}

/**
  * @brief  Main application entry point
  */
void UserApp_Main(void)
{
    PrintSystemInfo();

    printf("⚠️  IMPORTANT: Connect OV7670 XCLK to PA8!\n\n");

    printf("Starting OV7670 diagnostic with XCLK generation...\n");

    // XCLK 출력 설정 (가장 먼저!)
    Configure_MCO1_Output();

    // I2C 초기화
    Complete_I2C1_Reinit();

    // 진단 시작
    I2C_Scanner();
    OV7670_TryMultipleAddresses();

    printf("\n=== OV7670 Diagnostic Commands ===\n");
    printf("S - I2C bus scan\n");
    printf("P - Check I2C pin configuration\n");
    printf("F - Force GPIO configuration\n");
    printf("X - Complete I2C reinitialization\n");
    printf("C - Configure/Restart XCLK output\n");
    printf("1-5 - Change XCLK frequency\n");
    printf("M - Try multiple OV7670 addresses\n");
    printf("I - Check OV7670 ID\n");
    printf("R - Read key registers\n");
    printf("T - Basic configuration test\n");
    printf("A - Run ALL diagnostic tests\n");
    printf("H - Show this help\n");
    printf("===================================\n");
    printf("Ready for commands...\n\n");
}

/* USER CODE END 0 */
```

```c
  /* USER CODE BEGIN WHILE */
    UserApp_Main();

    uint8_t rx_buffer[1];

    while (1)
    {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */

      if (HAL_UART_Receive(&huart2, rx_buffer, 1, 10) == HAL_OK) {
          char received_char = (char)rx_buffer[0];

          if (received_char != '\r' && received_char != '\n') {
              printf("%c\n", received_char);
          }

          ProcessCommand(received_char);
          printf("> ");
      }

      HAL_Delay(1);

    }
  /* USER CODE END 3 */
```

