# ServerBot - STM32F103 서빙 로봇 시스템 분석

## 목차
1. [프로젝트 개요](#1-프로젝트-개요)
2. [하드웨어 구조 분석](#2-하드웨어-구조-분석)
3. [소프트웨어 구조 분석](#3-소프트웨어-구조-분석)
4. [타이밍 분석](#4-타이밍-분석)
5. [최적화 방안](#5-최적화-방안)

---

## 1. 프로젝트 개요

ServerBot은 STM32F103 마이크로컨트롤러 기반의 자율 서빙 로봇 시스템이다. 라인트레이서 센서를 활용하여 홈 위치에서 3개의 테이블까지 음식을 배달하고 자동으로 복귀하는 기능을 수행한다.

### 1.1 시스템 사양

| 항목 | 사양 |
|------|------|
| MCU | STM32F103 (Cortex-M3) |
| 시스템 클럭 | 64MHz (HSI 8MHz × PLL 16 ÷ 2) |
| 모터 구성 | 4륜 독립 구동 (LF, LB, RF, RB) |
| 센서 | 라인트레이서 2채널 + 물건 감지 1채널 |
| 통신 | UART2 115200bps |

### 1.2 동작 시퀀스

```
센서 코드:  (SEN1, SEN2)
경로:       홈(0,0) → (1,1) → (1,0)[T1] → (0,1)[T2] → (0,0)[T3]
                      zone=1   zone=2      zone=3      zone=4
```

---

## 2. 하드웨어 구조 분석

### 2.1 클럭 트리 구조

```
┌─────────────────────────────────────────────────────────────┐
│                    Clock Tree Structure                      │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   HSI (8MHz)                                                │
│       │                                                      │
│       ▼                                                      │
│   ÷2 (4MHz)                                                 │
│       │                                                      │
│       ▼                                                      │
│   ┌───────┐                                                 │
│   │  PLL  │ ×16                                             │
│   └───────┘                                                 │
│       │                                                      │
│       ▼                                                      │
│   SYSCLK = 64MHz                                            │
│       │                                                      │
│       ├──────────► AHB (64MHz) ──► Flash, DMA, GPIO         │
│       │            (÷1)                                      │
│       │                                                      │
│       ├──────────► APB1 (32MHz) ──► USART2, TIM2-4         │
│       │            (÷2)                                      │
│       │                                                      │
│       └──────────► APB2 (64MHz) ──► GPIO, USART1, TIM1      │
│                    (÷1)                                      │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 GPIO 핀 할당 매핑

#### 2.2.1 모터 제어 출력 (8핀)

```
┌─────────────────────────────────────────────────────────────┐
│                    Motor Driver Interface                    │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   [좌측 전륜 LF]          [우측 전륜 RF]                    │
│   ┌──────────┐            ┌──────────┐                      │
│   │ LFF (PB) │──► IN1     │ RFF (PB) │──► IN1              │
│   │ LFB (PA) │──► IN2     │ RFB (PB) │──► IN2              │
│   └──────────┘            └──────────┘                      │
│                                                              │
│   [좌측 후륜 LB]          [우측 후륜 RB]                    │
│   ┌──────────┐            ┌──────────┐                      │
│   │ LBF (PA) │──► IN1     │ RBF (PB) │──► IN1              │
│   │ LBB (PB) │──► IN2     │ RBB (PB) │──► IN2              │
│   └──────────┘            └──────────┘                      │
│                                                              │
│   GPIO Mode: Push-Pull, No Pull, Low Speed                  │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

#### 2.2.2 모터 방향 제어 로직

| 동작 | IN1 (Forward) | IN2 (Backward) |
|------|:-------------:|:--------------:|
| 정회전 | 1 | 0 |
| 역회전 | 0 | 1 |
| 정지 | 0 | 0 |

#### 2.2.3 센서 입력 (3핀)

```
┌─────────────────────────────────────────────────────────────┐
│                     Sensor Interface                         │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   GPIOC                                                      │
│   ┌───────────────────────────────────────────┐             │
│   │  LT1_Pin  │──────► 라인트레이서 센서 1    │             │
│   │  LT2_Pin  │──────► 라인트레이서 센서 2    │             │
│   │  ITEM_Pin │──────► 물건 감지 센서         │             │
│   └───────────────────────────────────────────┘             │
│                                                              │
│   GPIO Mode: Input, No Pull                                  │
│   물건 센서 극성: Active Low (물건 있음 = 0)                │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

#### 2.2.4 기타 핀

| 핀 | 포트 | 기능 |
|----|------|------|
| B1 | PC13 | 사용자 버튼 (EXTI Rising Edge) |
| LD2 | PA5 | 상태 LED |
| USART2_TX | PA2 | 디버그 출력 |
| USART2_RX | PA3 | 명령 입력 |

### 2.3 하드웨어 블록 다이어그램

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        ServerBot Hardware Architecture                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│    ┌──────────────┐                                                     │
│    │   PC/터미널   │                                                     │
│    │  (115200bps) │                                                     │
│    └──────┬───────┘                                                     │
│           │ UART                                                         │
│           ▼                                                              │
│    ┌─────────────────────────────────────────────────────┐              │
│    │                  STM32F103 MCU                       │              │
│    │  ┌─────────────────────────────────────────────┐    │              │
│    │  │              Cortex-M3 @ 64MHz               │    │              │
│    │  └─────────────────────────────────────────────┘    │              │
│    │                                                      │              │
│    │  ┌──────────┐  ┌──────────┐  ┌──────────────────┐  │              │
│    │  │  USART2  │  │   GPIO   │  │      EXTI        │  │              │
│    │  │ (Debug)  │  │ (Motor)  │  │  (Button IRQ)    │  │              │
│    │  └──────────┘  └──────────┘  └──────────────────┘  │              │
│    └───────┬────────────┬────────────────┬───────────────┘              │
│            │            │                │                               │
│            │            │                │                               │
│    ┌───────▼───────┐    │         ┌──────▼───────┐                      │
│    │   USB-UART    │    │         │   B1 Button  │                      │
│    │   Converter   │    │         │    (PC13)    │                      │
│    └───────────────┘    │         └──────────────┘                      │
│                         │                                                │
│            ┌────────────┼────────────────┐                              │
│            │            │                │                               │
│            ▼            ▼                ▼                               │
│    ┌───────────┐  ┌───────────┐  ┌───────────┐                         │
│    │  H-Bridge │  │  H-Bridge │  │  H-Bridge │  × 4 Motors             │
│    │  Driver   │  │  Driver   │  │  Driver   │                         │
│    └─────┬─────┘  └─────┬─────┘  └─────┬─────┘                         │
│          │              │              │                                 │
│          ▼              ▼              ▼                                 │
│    ┌─────────┐    ┌─────────┐    ┌─────────┐                           │
│    │   LF    │    │   RF    │    │ LB / RB │                           │
│    │  Motor  │    │  Motor  │    │ Motors  │                           │
│    └─────────┘    └─────────┘    └─────────┘                           │
│                                                                          │
│    ─────────────── 센서 입력 ───────────────                            │
│                                                                          │
│    ┌────────────┐  ┌────────────┐  ┌────────────┐                       │
│    │   LT1      │  │    LT2     │  │   ITEM     │                       │
│    │ Line Sens  │  │ Line Sens  │  │  Sensor    │                       │
│    └──────┬─────┘  └──────┬─────┘  └──────┬─────┘                       │
│           │               │               │                              │
│           └───────────────┴───────────────┘                              │
│                           │                                              │
│                           ▼                                              │
│                    GPIOC (Input)                                         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 3. 소프트웨어 구조 분석

### 3.1 소프트웨어 계층 구조

```
┌─────────────────────────────────────────────────────────────┐
│                  Software Layer Architecture                 │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   ┌───────────────────────────────────────────────────────┐ │
│   │              Application Layer (main.c)               │ │
│   │  ┌─────────────┐ ┌──────────────┐ ┌───────────────┐  │ │
│   │  │ State       │ │ Command      │ │ Sensor        │  │ │
│   │  │ Machine     │ │ Parser       │ │ Processing    │  │ │
│   │  └─────────────┘ └──────────────┘ └───────────────┘  │ │
│   └───────────────────────────────────────────────────────┘ │
│                            │                                 │
│   ┌───────────────────────────────────────────────────────┐ │
│   │              Motor Control Layer                      │ │
│   │  ┌─────────────┐ ┌──────────────┐ ┌───────────────┐  │ │
│   │  │ Wheel Ctrl  │ │ Motion Ctrl  │ │ Turn Control  │  │ │
│   │  │ LF/LB/RF/RB │ │ MF/MB/ML/MR  │ │ TLF/TRF/...   │  │ │
│   │  └─────────────┘ └──────────────┘ └───────────────┘  │ │
│   └───────────────────────────────────────────────────────┘ │
│                            │                                 │
│   ┌───────────────────────────────────────────────────────┐ │
│   │               HAL Driver Layer                        │ │
│   │  ┌─────────────┐ ┌──────────────┐ ┌───────────────┐  │ │
│   │  │ HAL_GPIO    │ │ HAL_UART     │ │ HAL_RCC       │  │ │
│   │  └─────────────┘ └──────────────┘ └───────────────┘  │ │
│   └───────────────────────────────────────────────────────┘ │
│                            │                                 │
│   ┌───────────────────────────────────────────────────────┐ │
│   │                  Hardware Layer                       │ │
│   │         STM32F103 (GPIO, USART, NVIC, RCC)           │ │
│   └───────────────────────────────────────────────────────┘ │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 상태 머신 설계

#### 3.2.1 상태 전이 다이어그램

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      State Machine Diagram                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│                    ┌──────────────────┐                                 │
│      ┌─────────────│   STATE 4        │◄────────────────┐               │
│      │             │   MANUAL MODE    │                 │               │
│      │             └────────┬─────────┘                 │               │
│      │                      │ '0' or 'X'                │ W/A/S/D       │
│      │                      ▼                           │ Q/E/Z/C       │
│      │             ┌──────────────────┐                 │               │
│      │ '1'/'2'/'3' │   STATE 0        │─────────────────┤               │
│      └─────────────│   HOME STANDBY   │                 │               │
│                    │   (ST)           │◄────────────────┤               │
│                    └────────┬─────────┘                 │               │
│                             │                           │               │
│                             │ target_table ≠ 0          │               │
│                             │ && item_sensor == 1       │               │
│                             ▼                           │               │
│                    ┌──────────────────┐                 │               │
│                    │   STATE 1        │                 │               │
│         '0' ┌─────►│   FORWARD        │                 │               │
│             │      │   (MF)           │                 │               │
│             │      └────────┬─────────┘                 │               │
│             │               │                           │               │
│             │               │ zone_count ==             │               │
│             │               │ target_zone               │               │
│             │               ▼                           │               │
│             │      ┌──────────────────┐                 │               │
│             │      │   STATE 2        │                 │               │
│             ├──────│   ARRIVED        │                 │               │
│             │      │   (ST)           │                 │               │
│             │      └────────┬─────────┘                 │               │
│             │               │                           │ 'X'           │
│             │               │ item_sensor == 0          │               │
│             │               ▼                           │               │
│             │      ┌──────────────────┐                 │               │
│             └──────│   STATE 3        ├─────────────────┘               │
│                    │   RETURN         │                                 │
│                    │   (MB)           │                                 │
│                    └────────┬─────────┘                                 │
│                             │                                            │
│                             │ (0,0) && zone passed                      │
│                             │                                            │
│                             ▼                                            │
│                      Back to STATE 0                                    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 3.2.2 상태 정의

| 상태 | 값 | 설명 | 모터 동작 |
|------|:--:|------|----------|
| HOME | 0 | 홈 대기 | 정지 (ST) |
| FORWARD | 1 | 전진 중 | 전진 (MF) |
| ARRIVED | 2 | 도착, 물건 제거 대기 | 정지 (ST) |
| RETURN | 3 | 복귀 중 | 후진 (MB) |
| MANUAL | 4 | 수동 조작 모드 | 사용자 제어 |

### 3.3 Zone 기반 위치 추적 시스템

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Zone-based Navigation System                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   물리적 경로 (단방향 트랙)                                              │
│                                                                          │
│   ┌─────┐     ┌─────┐     ┌─────┐     ┌─────┐     ┌─────┐             │
│   │ 홈  │────►│Zone1│────►│Zone2│────►│Zone3│────►│Zone4│             │
│   │(0,0)│     │(1,1)│     │(1,0)│     │(0,1)│     │(0,0)│             │
│   └─────┘     └─────┘     └──┬──┘     └──┬──┘     └──┬──┘             │
│                              │           │           │                  │
│                           Table1      Table2      Table3               │
│                                                                          │
│   ─────────────────────────────────────────────────────────────         │
│                                                                          │
│   전진 시퀀스 (zone_count 증가):                                        │
│   ┌─────────────────────────────────────────────────────────┐          │
│   │  센서 변화        zone_count    도착 조건               │          │
│   ├─────────────────────────────────────────────────────────┤          │
│   │  (0,0)→(1,1)         1         -                        │          │
│   │  (1,1)→(1,0)         2         target_table == 1        │          │
│   │  (1,0)→(0,1)         3         target_table == 2        │          │
│   │  (0,1)→(0,0)         4         target_table == 3        │          │
│   └─────────────────────────────────────────────────────────┘          │
│                                                                          │
│   복귀 시퀀스 (테이블별 역순):                                          │
│   ┌─────────────────────────────────────────────────────────┐          │
│   │  출발점    경로                                홈 도착   │          │
│   ├─────────────────────────────────────────────────────────┤          │
│   │  T1(1,0)   (1,0)→(1,1)→(0,0)                  zone=2    │          │
│   │  T2(0,1)   (0,1)→(1,0)→(1,1)→(0,0)           zone=3    │          │
│   │  T3(0,0)   (0,0)→(0,1)→(1,0)→(1,1)→(0,0)    zone=4    │          │
│   └─────────────────────────────────────────────────────────┘          │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.4 모터 제어 함수 구조

#### 3.4.1 함수 계층 구조

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Motor Control Function Hierarchy                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   High-Level Motion Commands                                             │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  MF()    MB()    ML()    MR()    ST()                           │   │
│   │  전진    후진    좌이동   우이동   정지                          │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                              │                                           │
│                              │                                           │
│   Turn Commands (Differential Drive)                                     │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  TLF()      TRF()      TLB()      TRB()                         │   │
│   │  좌회전     우회전     좌회전     우회전                         │   │
│   │  (전진)     (전진)     (후진)     (후진)                         │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                              │                                           │
│                              ▼                                           │
│   Low-Level Wheel Control                                                │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  LF(dir)    LB(dir)    RF(dir)    RB(dir)                       │   │
│   │    │          │          │          │                            │   │
│   │    │   dir=1: Forward    dir=0: Backward    dir=2: Stop         │   │
│   │    │                                                             │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                              │                                           │
│                              ▼                                           │
│   HAL GPIO Driver                                                        │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  HAL_GPIO_WritePin(Port, Pin, State)                            │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 3.4.2 모션 명령 - 휠 동작 매핑

| 명령 | LF | LB | RF | RB | 동작 |
|:----:|:--:|:--:|:--:|:--:|:----:|
| MF() | ▲ | ▲ | ▲ | ▲ | 전진 |
| MB() | ▼ | ▼ | ▼ | ▼ | 후진 |
| ML() | ▲ | ▲ | - | - | 좌이동 |
| MR() | - | - | ▲ | ▲ | 우이동 |
| TLF() | - | - | ▲ | ▲ | 좌회전(전진) |
| TRF() | ▲ | ▲ | - | - | 우회전(전진) |
| ST() | - | - | - | - | 정지 |

### 3.5 UART 명령 체계

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        UART Command Interface                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌───────────────────────────────────────────────────────────────┐     │
│   │                    테이블 목적지 설정                          │     │
│   │   '1' ─► Table 1    '2' ─► Table 2    '3' ─► Table 3         │     │
│   │   (STATE 0, 4에서만 가능)                                      │     │
│   └───────────────────────────────────────────────────────────────┘     │
│                                                                          │
│   ┌───────────────────────────────────────────────────────────────┐     │
│   │                    물건 센서 시뮬레이션                        │     │
│   │   'L'/'l' ─► LOAD (물건 올림)                                 │     │
│   │   'U'/'u' ─► UNLOAD (물건 내림)                               │     │
│   └───────────────────────────────────────────────────────────────┘     │
│                                                                          │
│   ┌───────────────────────────────────────────────────────────────┐     │
│   │                    시스템 제어                                  │     │
│   │   '0'   ─► 강제 홈 복귀 / 수동모드 해제                        │     │
│   │   'X'   ─► 비상 정지 (전체 리셋)                               │     │
│   └───────────────────────────────────────────────────────────────┘     │
│                                                                          │
│   ┌───────────────────────────────────────────────────────────────┐     │
│   │                    수동 조작 모드                               │     │
│   │                                                                │     │
│   │              Q (TRF)    W (MF)    E (TLF)                      │     │
│   │                           │                                    │     │
│   │              A (ML) ◄────┼────► D (MR)                        │     │
│   │                           │                                    │     │
│   │              Z (TRB)    S (MB)    C (TLB)                      │     │
│   │                                                                │     │
│   └───────────────────────────────────────────────────────────────┘     │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.6 메인 루프 실행 흐름

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        Main Loop Execution Flow                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   main()                                                                 │
│     │                                                                    │
│     ├──► HAL_Init()                                                     │
│     ├──► SystemClock_Config()    ─► 64MHz 설정                          │
│     ├──► MX_GPIO_Init()          ─► 모터/센서 핀 초기화                 │
│     ├──► MX_USART2_UART_Init()   ─► 115200bps 설정                      │
│     │                                                                    │
│     └──► while(1)                                                       │
│            │                                                             │
│            ▼                                                             │
│     ┌─────────────────────────────────────────────────────────────┐     │
│     │ [1] 센서 읽기                                                │     │
│     │     ├── SEN1 = HAL_GPIO_ReadPin(LT1)                        │     │
│     │     ├── SEN2 = HAL_GPIO_ReadPin(LT2)                        │     │
│     │     └── item_sensor = !HAL_GPIO_ReadPin(ITEM)               │     │
│     └─────────────────────────────────────────────────────────────┘     │
│            │                                                             │
│            ▼                                                             │
│     ┌─────────────────────────────────────────────────────────────┐     │
│     │ [2] UART 명령 처리 (Timeout: 10ms)                          │     │
│     │     └── HAL_UART_Receive() → switch(rx_data)                │     │
│     └─────────────────────────────────────────────────────────────┘     │
│            │                                                             │
│            ▼                                                             │
│     ┌─────────────────────────────────────────────────────────────┐     │
│     │ [3] 센서 변화 감지                                           │     │
│     │     └── sensor_changed = (SEN1≠prev || SEN2≠prev)           │     │
│     └─────────────────────────────────────────────────────────────┘     │
│            │                                                             │
│            ▼                                                             │
│     ┌─────────────────────────────────────────────────────────────┐     │
│     │ [4] 상태 머신 실행                                           │     │
│     │     └── switch(system_state) { case 0..4 }                  │     │
│     └─────────────────────────────────────────────────────────────┘     │
│            │                                                             │
│            ▼                                                             │
│     ┌─────────────────────────────────────────────────────────────┐     │
│     │ [5] 디버그 출력                                              │     │
│     │     └── printf("ST=%d, TBL=%d, ZONE=%d, ...")              │     │
│     └─────────────────────────────────────────────────────────────┘     │
│            │                                                             │
│            ▼                                                             │
│     ┌─────────────────────────────────────────────────────────────┐     │
│     │ [6] Delay                                                    │     │
│     │     └── HAL_Delay(50)   ─► 50ms 대기                        │     │
│     └─────────────────────────────────────────────────────────────┘     │
│            │                                                             │
│            └──► Loop 반복 (약 20Hz)                                     │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 4. 타이밍 분석

### 4.1 메인 루프 타이밍 분해

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Main Loop Timing Breakdown                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   System Clock: 64MHz  │  APB1 (UART): 32MHz  │  1 cycle ≈ 15.6ns      │
│                                                                          │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │              Component Execution Time Analysis                  │    │
│   ├─────────────────────────────┬──────────────┬───────────────────┤    │
│   │          동작                │   예상 시간   │       비고         │    │
│   ├─────────────────────────────┼──────────────┼───────────────────┤    │
│   │  GPIO Read (×3)             │    ~1 µs     │  HAL 오버헤드     │    │
│   │  UART Receive (timeout)     │   10 ms      │  ★ 최대 병목      │    │
│   │  UART Receive (data ready)  │   ~100 µs    │  실제 수신 시     │    │
│   │  State Machine Logic        │   ~10 µs     │  조건 분기        │    │
│   │  GPIO Write (×8)            │    ~3 µs     │  모터 제어        │    │
│   │  printf (debug output)      │   ~2-5 ms    │  ★ 가변 지연      │    │
│   │  HAL_Delay                  │   50 ms      │  ★ 고정 지연      │    │
│   ├─────────────────────────────┼──────────────┼───────────────────┤    │
│   │  Total (no input)           │  ~62-65 ms   │  ~15-16 Hz        │    │
│   │  Total (with input)         │  ~55-58 ms   │  ~17-18 Hz        │    │
│   └─────────────────────────────┴──────────────┴───────────────────┘    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.2 UART 타이밍 상세 분석

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      UART Timing Analysis                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   Configuration: 115200 bps, 8N1                                         │
│                                                                          │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                  UART Bit Timing                                │    │
│   ├────────────────────────────────────────────────────────────────┤    │
│   │                                                                 │    │
│   │   Baud Rate: 115200 bps                                        │    │
│   │   Bit Time:  1 / 115200 = 8.68 µs                             │    │
│   │                                                                 │    │
│   │   Frame Structure (1 byte):                                    │    │
│   │   ┌─────┬───────────────────┬─────┐                           │    │
│   │   │Start│    8 Data Bits    │Stop │  = 10 bits total          │    │
│   │   │ 1   │ D0 D1 D2 ... D7   │ 1   │                           │    │
│   │   └─────┴───────────────────┴─────┘                           │    │
│   │                                                                 │    │
│   │   1 Byte Transfer Time: 10 × 8.68µs = 86.8 µs                 │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                  Blocking Receive Impact                        │    │
│   ├────────────────────────────────────────────────────────────────┤    │
│   │                                                                 │    │
│   │   HAL_UART_Receive(&huart2, &rx_data, 1, 10)                   │    │
│   │                                      │                          │    │
│   │                                      └─► timeout = 10ms        │    │
│   │                                                                 │    │
│   │   Best Case (data ready):   ~100 µs                            │    │
│   │   Worst Case (no data):     10,000 µs (10 ms)                 │    │
│   │                                                                 │    │
│   │   문제점: 입력이 없어도 매 루프마다 10ms 블로킹                 │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                  printf() Output Timing                         │    │
│   ├────────────────────────────────────────────────────────────────┤    │
│   │                                                                 │    │
│   │   Debug Output Example:                                        │    │
│   │   "ST=1, TBL=2, ZONE=1, SEN=(1,0), LOAD\n"                    │    │
│   │   └─► 약 40 characters                                         │    │
│   │                                                                 │    │
│   │   Transfer Time: 40 × 86.8µs = 3.47 ms                        │    │
│   │                                                                 │    │
│   │   문제점: HAL_MAX_DELAY로 블로킹 전송                          │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.3 센서 응답 지연 분석

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Sensor Response Latency Analysis                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                  센서 변화 감지 시나리오                         │    │
│   ├────────────────────────────────────────────────────────────────┤    │
│   │                                                                 │    │
│   │   로봇 속도: v (mm/s)                                          │    │
│   │   루프 주기: T = 60ms (worst case)                             │    │
│   │                                                                 │    │
│   │   최대 감지 지연 거리: D = v × T                               │    │
│   │                                                                 │    │
│   │   예시 계산:                                                    │    │
│   │   ┌──────────────┬────────────┬─────────────────────────┐     │    │
│   │   │ 로봇 속도    │ 루프 주기  │ 최대 오버슈트 거리      │     │    │
│   │   ├──────────────┼────────────┼─────────────────────────┤     │    │
│   │   │  100 mm/s    │   60 ms    │      6.0 mm             │     │    │
│   │   │  200 mm/s    │   60 ms    │     12.0 mm             │     │    │
│   │   │  300 mm/s    │   60 ms    │     18.0 mm             │     │    │
│   │   │  500 mm/s    │   60 ms    │     30.0 mm             │     │    │
│   │   └──────────────┴────────────┴─────────────────────────┘     │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                  위치 정확도 영향                                │    │
│   ├────────────────────────────────────────────────────────────────┤    │
│   │                                                                 │    │
│   │         Sensor Zone        Actual Stop Position                │    │
│   │             │                      │                            │    │
│   │   ──────────┼──────────────────────┼────────────►               │    │
│   │             │◄── 최대 오버슈트 ──►│                            │    │
│   │                                                                 │    │
│   │   센서 변화 감지 시점과 실제 정지 사이의 지연으로               │    │
│   │   테이블 정위치 정렬에 오차 발생 가능                           │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.4 타이밍 문제점 요약

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      Timing Issues Summary                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │  Priority │ Issue                │ Impact        │ Severity    │    │
│   ├───────────┼──────────────────────┼───────────────┼─────────────┤    │
│   │    1      │ HAL_Delay(50) 고정   │ 실시간성 저하 │ ★★★ High   │    │
│   │           │ 지연                  │ ~16Hz 제한    │             │    │
│   ├───────────┼──────────────────────┼───────────────┼─────────────┤    │
│   │    2      │ UART Receive         │ 매 루프 10ms  │ ★★★ High   │    │
│   │           │ Blocking (10ms)      │ 블로킹        │             │    │
│   ├───────────┼──────────────────────┼───────────────┼─────────────┤    │
│   │    3      │ printf() Blocking    │ 2-5ms 추가    │ ★★☆ Medium │    │
│   │           │ 전송                  │ 지연          │             │    │
│   ├───────────┼──────────────────────┼───────────────┼─────────────┤    │
│   │    4      │ 센서 디바운싱 없음   │ 오동작 가능   │ ★★☆ Medium │    │
│   │           │                      │               │             │    │
│   ├───────────┼──────────────────────┼───────────────┼─────────────┤    │
│   │    5      │ GPIO 개별 제어       │ 모터 동기화   │ ★☆☆ Low    │    │
│   │           │ (non-atomic)         │ 미세 오차     │             │    │
│   └───────────┴──────────────────────┴───────────────┴─────────────┘    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 5. 최적화 방안

### 5.1 타이밍 최적화

#### 5.1.1 UART 비동기 처리

```
┌─────────────────────────────────────────────────────────────────────────┐
│              Optimization 1: Non-blocking UART Reception                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   현재 구현 (Blocking)                                                   │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   Main Loop                                                    │    │
│   │   ┌─────┐  ┌────────────────────┐  ┌─────┐                    │    │
│   │   │Sense│──│ UART Wait (10ms)   │──│Logic│──► ...             │    │
│   │   └─────┘  └────────────────────┘  └─────┘                    │    │
│   │                ▲                                               │    │
│   │                │ CPU 블로킹                                    │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│   개선 방안 1: Interrupt 기반 수신                                       │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   UART ISR ─────────────────────► Ring Buffer                  │    │
│   │        │                              │                         │    │
│   │        └─► HAL_UART_RxCpltCallback()  │                         │    │
│   │                                       ▼                         │    │
│   │   Main Loop                      ┌────────┐                    │    │
│   │   ┌─────┐  ┌─────┐  ┌─────┐     │ Buffer │                    │    │
│   │   │Sense│──│Logic│──│Motor│◄────│  Read  │                    │    │
│   │   └─────┘  └─────┘  └─────┘     └────────┘                    │    │
│   │                                                                 │    │
│   │   ★ Non-blocking: CPU 사용률 최적화                            │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│   개선 방안 2: DMA 기반 수신                                             │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   UART ──► DMA ──► Circular Buffer ──► Main Loop              │    │
│   │                                                                 │    │
│   │   ★ Zero CPU overhead for data transfer                       │    │
│   │   ★ HAL_UART_Receive_DMA() 활용                               │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│   예상 개선 효과:                                                        │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │   항목            │ Before    │ After     │ Improvement        │    │
│   ├───────────────────┼───────────┼───────────┼────────────────────┤    │
│   │   UART 처리 시간  │ 10 ms     │ ~10 µs    │ 1000x 향상        │    │
│   │   루프 주기       │ ~60 ms    │ ~52 ms    │ 13% 감소          │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 5.1.2 타이머 기반 주기 제어

```
┌─────────────────────────────────────────────────────────────────────────┐
│              Optimization 2: Timer-based Loop Control                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   현재 구현 (HAL_Delay)                                                  │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   ┌──────┐   ┌──────────────────────────────────┐              │    │
│   │   │ Work │───│        HAL_Delay(50)             │──► Loop     │    │
│   │   │ 10ms │   │        (Fixed 50ms)              │              │    │
│   │   └──────┘   └──────────────────────────────────┘              │    │
│   │                                                                 │    │
│   │   Total: 10 + 50 = 60ms (가변)                                 │    │
│   │   문제점: 작업 시간에 따라 실제 주기 변동                       │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│   개선 방안: TIM 인터럽트 기반 주기적 실행                               │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   TIM2 (Period: 20ms = 50Hz)                                   │    │
│   │        │                                                        │    │
│   │        ▼                                                        │    │
│   │   ┌────────────────────┐                                       │    │
│   │   │ Update Flag = 1    │ ──► ISR                               │    │
│   │   └────────────────────┘                                       │    │
│   │                                                                 │    │
│   │   Main Loop:                                                   │    │
│   │   while(1) {                                                   │    │
│   │       if (flag) {                                              │    │
│   │           flag = 0;                                            │    │
│   │           Process();   // 정확히 20ms 주기                     │    │
│   │       }                                                        │    │
│   │       // Low-power wait or other tasks                         │    │
│   │   }                                                            │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│   타이머 설정 예시:                                                      │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │   Clock Source: APB1 Timer Clock = 64MHz                       │    │
│   │   Prescaler:    6400 - 1  (64MHz / 6400 = 10kHz)              │    │
│   │   Period:       200 - 1   (10kHz / 200 = 50Hz = 20ms)         │    │
│   │                                                                 │    │
│   │   또는 100Hz (10ms) 설정:                                       │    │
│   │   Prescaler:    6400 - 1                                       │    │
│   │   Period:       100 - 1                                        │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 5.1.3 디버그 출력 최적화

```
┌─────────────────────────────────────────────────────────────────────────┐
│              Optimization 3: Debug Output Optimization                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   현재 구현                                                              │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   printf() ──► HAL_UART_Transmit() ──► Blocking Wait          │    │
│   │               (HAL_MAX_DELAY)                                   │    │
│   │                                                                 │    │
│   │   매 루프 ~40 chars × 86.8µs = 3.47ms 블로킹                   │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│   개선 방안 1: DMA 기반 비동기 전송                                      │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   printf() ──► TX Buffer ──► DMA Transfer ──► UART            │    │
│   │                    │                                            │    │
│   │                    └─► CPU 즉시 반환 (non-blocking)            │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│   개선 방안 2: 조건부 출력                                               │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   // 상태 변화 시에만 출력                                      │    │
│   │   if (state_changed || sensor_changed) {                       │    │
│   │       printf(...);                                              │    │
│   │   }                                                             │    │
│   │                                                                 │    │
│   │   // 또는 N번째 루프마다 출력                                   │    │
│   │   if (loop_count % 10 == 0) {                                  │    │
│   │       printf(...);                                              │    │
│   │   }                                                             │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│   개선 방안 3: 컴파일 조건부 제거                                        │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   #ifdef DEBUG_ENABLE                                          │    │
│   │   #define DEBUG_PRINT(fmt, ...) printf(fmt, ##__VA_ARGS__)    │    │
│   │   #else                                                         │    │
│   │   #define DEBUG_PRINT(fmt, ...) ((void)0)                      │    │
│   │   #endif                                                        │    │
│   │                                                                 │    │
│   │   // 릴리즈 빌드에서 완전히 제거됨                              │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 5.2 센서 처리 최적화

#### 5.2.1 EXTI 인터럽트 기반 센서 처리

```
┌─────────────────────────────────────────────────────────────────────────┐
│              Optimization 4: EXTI-based Sensor Handling                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   현재 구현 (Polling)                                                    │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   while(1) {                                                   │    │
│   │       SEN1 = HAL_GPIO_ReadPin(LT1);   // 매번 폴링             │    │
│   │       SEN2 = HAL_GPIO_ReadPin(LT2);   // 매번 폴링             │    │
│   │       if (SEN1 != prev1 || SEN2 != prev2) {                    │    │
│   │           // 변화 처리                                          │    │
│   │       }                                                         │    │
│   │   }                                                             │    │
│   │                                                                 │    │
│   │   문제점: 폴링 주기(60ms) 사이의 변화를 놓칠 수 있음            │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│   개선 방안: EXTI 양방향 에지 인터럽트                                   │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   GPIO Configuration:                                          │    │
│   │   ┌─────────────────────────────────────────────┐             │    │
│   │   │  Mode: GPIO_MODE_IT_RISING_FALLING          │             │    │
│   │   │  Pull: GPIO_PULLUP or GPIO_PULLDOWN         │             │    │
│   │   └─────────────────────────────────────────────┘             │    │
│   │                                                                 │    │
│   │   ISR Handler:                                                 │    │
│   │   ┌─────────────────────────────────────────────────────────┐ │    │
│   │   │  void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {       │ │    │
│   │   │      if (GPIO_Pin == LT1_Pin || GPIO_Pin == LT2_Pin) {  │ │    │
│   │   │          sensor_event_flag = 1;                          │ │    │
│   │   │          latest_SEN1 = HAL_GPIO_ReadPin(LT1);           │ │    │
│   │   │          latest_SEN2 = HAL_GPIO_ReadPin(LT2);           │ │    │
│   │   │      }                                                   │ │    │
│   │   │  }                                                       │ │    │
│   │   └─────────────────────────────────────────────────────────┘ │    │
│   │                                                                 │    │
│   │   장점:                                                         │    │
│   │   - 센서 변화 즉시 감지 (µs 단위 응답)                         │    │
│   │   - 고속 이동 시에도 정확한 위치 감지                          │    │
│   │   - CPU 부하 감소 (이벤트 기반)                                │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 5.2.2 소프트웨어 디바운싱

```
┌─────────────────────────────────────────────────────────────────────────┐
│              Optimization 5: Software Debouncing                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   센서 바운싱 문제                                                       │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   실제 신호:    ─────┐     ┌─────────────────                  │    │
│   │                      │     │                                    │    │
│   │                      └─────┘                                    │    │
│   │                                                                 │    │
│   │   바운싱:       ─────┐ ┌─┐ ┌─────────────────                  │    │
│   │                      │ │ │ │                                    │    │
│   │                      └─┘ └─┘                                    │    │
│   │                      ◄──────►                                   │    │
│   │                      ~1-5ms (기계적 바운싱)                     │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│   개선 방안: 연속 샘플링 기반 디바운싱                                   │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   #define DEBOUNCE_COUNT 3                                     │    │
│   │                                                                 │    │
│   │   uint8_t debounce_sensor(uint8_t current, uint8_t *counter,   │    │
│   │                           uint8_t *stable) {                    │    │
│   │       if (current == *stable) {                                │    │
│   │           *counter = 0;                                         │    │
│   │       } else {                                                  │    │
│   │           (*counter)++;                                         │    │
│   │           if (*counter >= DEBOUNCE_COUNT) {                    │    │
│   │               *stable = current;                                │    │
│   │               *counter = 0;                                     │    │
│   │               return 1;  // 상태 변화 확정                      │    │
│   │           }                                                     │    │
│   │       }                                                         │    │
│   │       return 0;                                                 │    │
│   │   }                                                             │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│   개선 방안: 타임스탬프 기반 디바운싱                                    │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   #define DEBOUNCE_TIME_MS 10                                  │    │
│   │                                                                 │    │
│   │   if (current != stable) {                                     │    │
│   │       if (HAL_GetTick() - last_change_tick > DEBOUNCE_TIME_MS) │    │
│   │       {                                                         │    │
│   │           stable = current;                                     │    │
│   │           // 처리                                               │    │
│   │       }                                                         │    │
│   │   }                                                             │    │
│   │   last_change_tick = HAL_GetTick();                            │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 5.3 코드 구조 최적화

#### 5.3.1 GPIO 원자적 제어

```
┌─────────────────────────────────────────────────────────────────────────┐
│              Optimization 6: Atomic GPIO Control                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   현재 구현 (순차적 개별 핀 제어)                                        │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   void MF() {                                                  │    │
│   │       HAL_GPIO_WritePin(LFF_Port, LFF_Pin, 1);  // t+0        │    │
│   │       HAL_GPIO_WritePin(LFB_Port, LFB_Pin, 0);  // t+1        │    │
│   │       HAL_GPIO_WritePin(RFF_Port, RFF_Pin, 1);  // t+2        │    │
│   │       // ... 8번의 개별 호출                                   │    │
│   │   }                                                             │    │
│   │                                                                 │    │
│   │   문제점:                                                       │    │
│   │   - 8개 핀 제어에 8번의 함수 호출                              │    │
│   │   - 핀 간 수 µs 지연 발생                                       │    │
│   │   - 모터 간 미세한 타이밍 차이                                  │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│   개선 방안: BSRR 레지스터 직접 접근                                     │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   // GPIOB 핀들을 한 번에 제어                                  │    │
│   │   // Set: Bits 0-15, Reset: Bits 16-31                         │    │
│   │   #define MOTOR_GPIOB_FWD_MASK  (LFF_Pin | RFF_Pin | ...)     │    │
│   │   #define MOTOR_GPIOB_BWD_MASK  (LFB_Pin | RFB_Pin | ...)     │    │
│   │                                                                 │    │
│   │   void MF_Optimized() {                                        │    │
│   │       // GPIOB: Set forward pins, Reset backward pins         │    │
│   │       GPIOB->BSRR = MOTOR_GPIOB_FWD_MASK |                     │    │
│   │                     (MOTOR_GPIOB_BWD_MASK << 16);              │    │
│   │                                                                 │    │
│   │       // GPIOA: 동일하게 처리                                  │    │
│   │       GPIOA->BSRR = MOTOR_GPIOA_FWD_MASK |                     │    │
│   │                     (MOTOR_GPIOA_BWD_MASK << 16);              │    │
│   │   }                                                             │    │
│   │                                                                 │    │
│   │   장점:                                                         │    │
│   │   - 같은 포트의 모든 핀 동시 제어                              │    │
│   │   - 2번의 레지스터 쓰기로 8핀 제어                             │    │
│   │   - 함수 호출 오버헤드 제거                                     │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 5.3.2 모터 제어 함수 통합

```
┌─────────────────────────────────────────────────────────────────────────┐
│              Optimization 7: Unified Motor Control                       │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   현재 구현: 중복 코드 다수                                              │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   int LF(int dir) { switch(dir) { case 1: ... case 0: ... } } │    │
│   │   int LB(int dir) { switch(dir) { case 1: ... case 0: ... } } │    │
│   │   int RF(int dir) { switch(dir) { case 1: ... case 0: ... } } │    │
│   │   int RB(int dir) { switch(dir) { case 1: ... case 0: ... } } │    │
│   │   // 유사한 구조 4번 반복                                       │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│   개선 방안: 구조체 및 테이블 기반 통합                                  │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   typedef struct {                                             │    │
│   │       GPIO_TypeDef *fwd_port;                                  │    │
│   │       uint16_t      fwd_pin;                                   │    │
│   │       GPIO_TypeDef *bwd_port;                                  │    │
│   │       uint16_t      bwd_pin;                                   │    │
│   │   } Motor_t;                                                   │    │
│   │                                                                 │    │
│   │   const Motor_t motors[4] = {                                  │    │
│   │       {LFF_GPIO_Port, LFF_Pin, LFB_GPIO_Port, LFB_Pin}, // LF │    │
│   │       {LBF_GPIO_Port, LBF_Pin, LBB_GPIO_Port, LBB_Pin}, // LB │    │
│   │       {RFF_GPIO_Port, RFF_Pin, RFB_GPIO_Port, RFB_Pin}, // RF │    │
│   │       {RBF_GPIO_Port, RBF_Pin, RBB_GPIO_Port, RBB_Pin}, // RB │    │
│   │   };                                                           │    │
│   │                                                                 │    │
│   │   typedef enum { MOTOR_STOP=0, MOTOR_FWD=1, MOTOR_BWD=2 } Dir; │    │
│   │                                                                 │    │
│   │   void motor_set(uint8_t idx, Dir dir) {                       │    │
│   │       HAL_GPIO_WritePin(motors[idx].fwd_port,                  │    │
│   │                         motors[idx].fwd_pin, dir == MOTOR_FWD);│    │
│   │       HAL_GPIO_WritePin(motors[idx].bwd_port,                  │    │
│   │                         motors[idx].bwd_pin, dir == MOTOR_BWD);│    │
│   │   }                                                             │    │
│   │                                                                 │    │
│   │   void motor_set_all(Dir lf, Dir lb, Dir rf, Dir rb) {         │    │
│   │       motor_set(0, lf);                                         │    │
│   │       motor_set(1, lb);                                         │    │
│   │       motor_set(2, rf);                                         │    │
│   │       motor_set(3, rb);                                         │    │
│   │   }                                                             │    │
│   │                                                                 │    │
│   │   // 사용 예시                                                  │    │
│   │   #define MF() motor_set_all(MOTOR_FWD, MOTOR_FWD, ...)        │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 5.4 안전 및 신뢰성 최적화

#### 5.4.1 Watchdog 구현

```
┌─────────────────────────────────────────────────────────────────────────┐
│              Optimization 8: Watchdog Timer Implementation               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   문제점: 무한루프/행 발생 시 시스템 복구 불가                          │
│                                                                          │
│   개선 방안: IWDG (Independent Watchdog) 활성화                         │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   초기화:                                                       │    │
│   │   ┌─────────────────────────────────────────────────────────┐  │    │
│   │   │  hiwdg.Instance = IWDG;                                 │  │    │
│   │   │  hiwdg.Init.Prescaler = IWDG_PRESCALER_64;             │  │    │
│   │   │  hiwdg.Init.Reload = 1250;  // ~2초 타임아웃            │  │    │
│   │   │  HAL_IWDG_Init(&hiwdg);                                 │  │    │
│   │   └─────────────────────────────────────────────────────────┘  │    │
│   │                                                                 │    │
│   │   메인 루프:                                                    │    │
│   │   ┌─────────────────────────────────────────────────────────┐  │    │
│   │   │  while(1) {                                             │  │    │
│   │   │      // ... 정상 동작 ...                               │  │    │
│   │   │      HAL_IWDG_Refresh(&hiwdg);  // Watchdog 리프레시   │  │    │
│   │   │  }                                                      │  │    │
│   │   └─────────────────────────────────────────────────────────┘  │    │
│   │                                                                 │    │
│   │   동작:                                                         │    │
│   │   - 정상: 매 루프마다 리프레시 → 타이머 리셋                   │    │
│   │   - 이상: 2초 내 리프레시 없음 → 시스템 리셋                   │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 5.4.2 에러 핸들링 개선

```
┌─────────────────────────────────────────────────────────────────────────┐
│              Optimization 9: Enhanced Error Handling                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   현재 구현                                                              │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   void Error_Handler(void) {                                   │    │
│   │       __disable_irq();                                          │    │
│   │       while(1) { }  // 무한 정지                               │    │
│   │   }                                                             │    │
│   │                                                                 │    │
│   │   문제점:                                                       │    │
│   │   - 에러 원인 추적 불가                                        │    │
│   │   - 복구 불가 (수동 리셋 필요)                                 │    │
│   │   - 모터가 마지막 상태 유지 (위험)                             │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
│   개선 방안                                                              │
│   ┌────────────────────────────────────────────────────────────────┐    │
│   │                                                                 │    │
│   │   typedef enum {                                               │    │
│   │       ERR_NONE = 0,                                            │    │
│   │       ERR_CLOCK_FAIL,                                          │    │
│   │       ERR_UART_FAIL,                                           │    │
│   │       ERR_SENSOR_TIMEOUT,                                      │    │
│   │       ERR_MOTOR_FAULT,                                         │    │
│   │   } ErrorCode_t;                                               │    │
│   │                                                                 │    │
│   │   void Error_Handler_Ex(ErrorCode_t code) {                    │    │
│   │       // 1. 모터 즉시 정지 (안전 조치)                         │    │
│   │       ST();                                                     │    │
│   │                                                                 │    │
│   │       // 2. LED로 에러 코드 표시                               │    │
│   │       for (int i = 0; i < code; i++) {                         │    │
│   │           HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);          │    │
│   │           HAL_Delay(200);                                       │    │
│   │       }                                                         │    │
│   │                                                                 │    │
│   │       // 3. UART로 에러 로그 전송 (가능한 경우)                │    │
│   │       printf("FATAL ERROR: %d\n", code);                       │    │
│   │                                                                 │    │
│   │       // 4. Watchdog 타임아웃으로 자동 리셋                    │    │
│   │       while(1) { }                                              │    │
│   │   }                                                             │    │
│   │                                                                 │    │
│   └────────────────────────────────────────────────────────────────┘    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 5.5 최적화 효과 요약

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Optimization Impact Summary                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │  #  │ Optimization        │ Before   │ After    │ Benefit      │   │
│   ├─────┼─────────────────────┼──────────┼──────────┼──────────────┤   │
│   │  1  │ Non-blocking UART   │ 10 ms    │ ~10 µs   │ 1000x faster │   │
│   │  2  │ Timer-based Loop    │ Variable │ Fixed    │ Determinism  │   │
│   │  3  │ DMA Debug Output    │ 3-5 ms   │ ~0 ms    │ CPU free     │   │
│   │  4  │ EXTI Sensors        │ 60 ms    │ ~1 µs    │ Instant resp │   │
│   │  5  │ Debouncing          │ Glitch   │ Stable   │ Reliability  │   │
│   │  6  │ Atomic GPIO         │ 8 calls  │ 2 calls  │ 4x faster    │   │
│   │  7  │ Unified Motor API   │ 400 LOC  │ ~100 LOC │ Maintainab.  │   │
│   │  8  │ Watchdog            │ Hang     │ Reset    │ Safety       │   │
│   │  9  │ Error Handling      │ Silent   │ Logged   │ Debuggable   │   │
│   └─────┴─────────────────────┴──────────┴──────────┴──────────────┘   │
│                                                                          │
│   전체 루프 주기 개선:                                                   │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │                                                                  │   │
│   │   Before: ~60-65 ms (15-16 Hz)                                  │   │
│   │                                                                  │   │
│   │   After (All Optimizations):  ~1-2 ms (configurable)            │   │
│   │                                                                  │   │
│   │   Achievable: 100 Hz - 1 kHz 제어 주기                          │   │
│   │                                                                  │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 부록: 참조 자료

### 레지스터 매핑

| 레지스터 | 주소 | 용도 |
|----------|------|------|
| GPIOA_BSRR | 0x40010810 | Port A Bit Set/Reset |
| GPIOB_BSRR | 0x40010C10 | Port B Bit Set/Reset |
| GPIOC_IDR | 0x40011008 | Port C Input Data |

### 관련 문서

- STM32F103 Reference Manual (RM0008)
- STM32F103 Datasheet
- STM32 HAL Driver User Manual (UM1850)

---

*이 문서는 ServerBot 서빙 로봇 프로젝트의 기술 분석 자료입니다.*
